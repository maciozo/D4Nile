\documentclass[a4paper,11pt]{article}
\usepackage[margin=1in]{geometry}
\renewcommand{\baselinestretch}{1.2} % line spacing
\usepackage{listings}
\usepackage{color}
\usepackage{siunitx}
\usepackage{graphicx}
\usepackage{epstopdf}
\usepackage{float}
\usepackage{pdfpages}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=tb,
  language=C,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3,
  numbers=left
}

\begin{document}

\lstset{caption={Constants header. Currently used for UART protocol. (constants.h)}, label=ls:constants_h}\linespread{0.8}
\begin{lstlisting}
#ifndef _CONSTANTS_H
#define _CONSTANTS_H

/* ==============================MC -> Pi UART Protocol===================== */

    /* Accelerometer data */
    #define ACC_X 0x20
    #define ACC_Y 0x21
    #define ACC_Z 0x22

    /* Gyroscope data */
    #define GYR_X 0x23
    #define GYR_Y 0x24
    #define GYR_Z 0x25

    /* Magnetometer data */
    #define MAG_X 0x26
    #define MAG_Y 0x27
    #define MAG_Z 0x28

    /* Altitude data */
    #define IR 0x29
    #define USONIC 0x2A

    /* Temperature data */
    #define TEMP_BAT 0x2B
    #define TEMP_M0 0x2C
    #define TEMP_M1 0x2D
    #define TEMP_M2 0x2E
    #define TEMP_M3 0x2F
    #define TEMP_AIR 0x30

    /* GPS data */
    #define GPS_N 0x31
    #define GPS_E 0x32
    #define GPS_A 0x33
    
    #define RECV_MAX 0x33
    
/* ========================================================================== */

/* ==============================Pi -> MC UART Protocol===================== */

    #define YAW_LEFT 0x20
    #define THROTTLE_UP 0x21
    
    #define ROLL_LEFT 0x22
    #define PITCH_FORWARD 0x23

    #define X_BUTTON 0x24

/* ========================================================================== */

#endif
\end{lstlisting}

\lstset{caption={Raspberry Pi UART Comms (rpi/mc\_comms.cc)}, label=ls:mcomms}\linespread{0.8}
\begin{lstlisting}
#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/mman.h>
#include <time.h>
#include <string.h>

#include "mc_comms.hh"
#include "../constants.h"

FILE* uartInit(const char* device)
{
    static FILE *serial = fopen(device, "r+");
    
    /* Making fgets non-blocking 
    http://stackoverflow.com/a/6055774 */
    int fd = fileno(serial);
    int flags = fcntl(fd, F_GETFL, 0);
    flags |= O_NONBLOCK;
    fcntl(fd, F_SETFL, flags);
    
    /* fclose(serial); */
    
    return serial;
}

void uartClose(FILE* uartDevice)
{
    fclose(uartDevice);
}

int uartSendRaw(char* string, FILE* uartDevice)
{
    if (strlen(string) > SENDBUFFER_SIZE)
    {
        return 1;
    }
    fwrite(string, sizeof(char), SENDBUFFER_SIZE, uartDevice);
    return 0;
}

int uartSendCommand(uint8_t command, int16_t data, FILE* uartDevice)
{
    char toSend[5];
    if ((command < 0x20) | (command > RECV_MAX))
    {
        return 1;
    }
    
    /*
        Convert 8 bit command and 16 bit data in to a 24 bit string.
        8 bit command, 2x 8 bit data.
        CCCCCCCC|DDDDDDDD|DDDDDDDD
    */
    toSend[0] = (char)command;
    toSend[1] = (char)(data >> 8);
    toSend[2] = (char)(data & 0x00FF);
    toSend[3] = (char)'\n';
    toSend[4] = (char)'\0';
    
    uartSendRaw(toSend, uartDevice);
    
    return 0;
}

int uartReadRaw(FILE* uartDevice, char* recvBuffer)
{    
    if (fgets(recvBuffer, RECVBUFFER_SIZE, uartDevice) != NULL)
    {
        return 0;
    }
    return 1;
}
\end{lstlisting}

\lstset{caption={Joystick++ header (rpi/joystick.hh)}, label=ls:joystick_h}\linespread{0.8}
\begin{lstlisting}
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Copyright Drew Noakes 2013-2016

#ifndef __JOYSTICK_HH__
#define __JOYSTICK_HH__

#include <string>
#include <iostream>

#define JS_EVENT_BUTTON 0x01 // button pressed/released
#define JS_EVENT_AXIS   0x02 // joystick moved
#define JS_EVENT_INIT   0x80 // initial state of device

/**
 * Encapsulates all data relevant to a sampled joystick event.
 */
class JoystickEvent
{
public:
  /** Minimum value of axes range */
  static const int16_t MIN_AXES_VALUE = -32768;

  /** Minimum value of axes range */
  static const int16_t MAX_AXES_VALUE = 32767;
  
  /**
   * The timestamp of the event, in milliseconds.
   */
  unsigned int time;
  
  /**
   * The value associated with this joystick event.
   * For buttons this will be either 1 (down) or 0 (up).
   * For axes, this will range between MIN_AXES_VALUE and MAX_AXES_VALUE.
   */
  int16_t value;
  
  /**
   * The event type.
   */
  unsigned char type;
  
  /**
   * The axis/button number.
   */
  unsigned char number;

  /**
   * Returns true if this event is the result of a button press.
   */
  bool isButton()
  {
    return (type & JS_EVENT_BUTTON) != 0;
  }

  /**
   * Returns true if this event is the result of an axis movement.
   */
  bool isAxis()
  {
    return (type & JS_EVENT_AXIS) != 0;
  }

  /**
   * Returns true if this event is part of the initial state obtained when
   * the joystick is first connected to.
   */
  bool isInitialState()
  {
    return (type & JS_EVENT_INIT) != 0;
  }

  /**
   * The ostream inserter needs to be a friend so it can access the
   * internal data structures.
   */
  friend std::ostream& operator<<(std::ostream& os, const JoystickEvent& e);
};

/**
 * Stream insertion function so you can do this:
 *    cout << event << endl;
 */
std::ostream& operator<<(std::ostream& os, const JoystickEvent& e);

/**
 * Represents a joystick device. Allows data to be sampled from it.
 */
class Joystick
{
private:
  void openPath(std::string devicePath, bool blocking=false);
  
  int _fd;
  
public:
  ~Joystick();

  /**
   * Initialises an instance for the first joystick: /dev/input/js0
   */
  Joystick();

  /**
   * Initialises an instance for the joystick with the specified,
   * zero-indexed number.
   */
  Joystick(int joystickNumber);

  /**
   * Initialises an instance for the joystick device specified.
   */
  Joystick(std::string devicePath);

  /**
   * Initialises an instance for the joystick device specified and provide
   * the option of blocking I/O.
   */
  Joystick(std::string devicePath, bool blocking);
 
  /**
   * Returns true if the joystick was found and may be used, otherwise false.
   */
  bool isFound();
  
  /**
   * Attempts to populate the provided JoystickEvent instance with data
   * from the joystick. Returns true if data is available, otherwise false.
   */
  bool sample(JoystickEvent* event);
};

#endif
\end{lstlisting}

\lstset{caption={Joystick++ (rpi/joystick.cc)}, label=ls:joystick}\linespread{0.8}
\begin{lstlisting}
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Copyright Drew Noakes 2013-2016

#include "joystick.hh"

#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <iostream>
#include <string>
#include <sstream>
#include "unistd.h"

Joystick::Joystick()
{
  openPath("/dev/input/js0");
}

Joystick::Joystick(int joystickNumber)
{
  std::stringstream sstm;
  sstm << "/dev/input/js" << joystickNumber;
  openPath(sstm.str());
}

Joystick::Joystick(std::string devicePath)
{
  openPath(devicePath);
}

Joystick::Joystick(std::string devicePath, bool blocking)
{
  openPath(devicePath, blocking);
}

void Joystick::openPath(std::string devicePath, bool blocking)
{
  // Open the device using either blocking or non-blocking
  _fd = open(devicePath.c_str(), blocking ? O_RDONLY : O_RDONLY | O_NONBLOCK);
}

bool Joystick::sample(JoystickEvent* event)
{
  int bytes = read(_fd, event, sizeof(*event)); 

  if (bytes == -1)
    return false;

  // NOTE if this condition is not met, we're probably out of sync and this
  // Joystick instance is likely unusable
  return bytes == sizeof(*event);
}

bool Joystick::isFound()
{
  return _fd >= 0;
}

Joystick::~Joystick()
{
  close(_fd);
}

std::ostream& operator<<(std::ostream& os, const JoystickEvent& e)
{
  os << "type=" << static_cast<int>(e.type)
     << " number=" << static_cast<int>(e.number)
     << " value=" << static_cast<int>(e.value);
  return os;
}
\end{lstlisting}

\lstset{caption={Type definition for sensor data (rpi/sensorData.hh)}, label=ls:sensorData_h}\linespread{0.8}
\begin{lstlisting}
#ifndef _SD_H
#define _SD_H

typedef struct
{
  int16_t acc_x;
  int16_t acc_y;
  int16_t acc_z;
  
  int16_t gyr_x;
  int16_t gyr_y;
  int16_t gyr_z;
  
  int16_t mag_x;
  int16_t mag_y;
  int16_t mag_z;
  
  int16_t ir;
  int16_t usonic;
  
  int16_t temp_bat;
  int16_t temp_m0;
  int16_t temp_m1;
  int16_t temp_m2;
  int16_t temp_m3;
  int16_t temp_air;
  
  int16_t gps_n;
  int16_t gps_e;
  int16_t gps_a;
} sensordata_t;

#endif
\end{lstlisting}

\lstset{caption={Function for formatting incoming sensor data. (rpi/sensorData.cc)}, label=ls:sensorData}\linespread{0.8}
\begin{lstlisting}
#include "sensorData.h"

int formatData(sensordata_t* sensorData, char* rawdata)
{
    tempData = (rawdata[1] << 8) | rawdata[2];
    switch (rawdata[0])
    {
        case ACC_X:
            sensorData->acc_x = tempData;
            break;
        case ACC_Y:
            sensorData->acc_y = tempData;
            break;
        case ACC_Z:
            sensorData->acc_z = tempData;
            break;
            
        case GYR_X:
            sensorData->gyr_x = tempData;
            break;
        case GYR_Y:
            sensorData->gyr_y = tempData;
            break;
        case GYR_Z:
            sensorData->gyr_z = tempData;
            break;
            
        case MAG_X:
            sensorData->mag_x = tempData;
            break;
        case MAG_Y:
            sensorData->mag_y = tempData;
            break;
        case MAG_Z:
            sensorData->mag_z = tempData;
            break;
        
        case IR:
            sensorData->ir = tempData;
            break;
        case USONIC:
            sensorData->usonic = tempData;
        
        case TEMP_BAT:
            sensorData->temp_bat = tempData;
            break;
        case TEMP_M0:
            sensorData->temp_m0 = tempData;
            break;
        case TEMP_M1:
            sensorData->temp_m1 = tempData;
            break;
        case TEMP_M2:
            sensorData->temp_m2 = tempData;
            break;
        case TEMP_M3:
            sensorData->temp_m3 = tempData;
            break;
        case TEMP_AIR:
            sensorData->temp_air = tempData;
            break;
            
        case GPS_X:
            sensorData->gps_n = tempData;
            break;
        case GPS_Y:
            sensorData->gps_e = tempData;
            break;
        case GPS_Z:
            sensorData->gps_a = tempData;
            break;
            
        default:
            printf("Unknown control byte: 0x%x\n", rawdata[0]);
            printf("\tPayload: 0x%x 0x%x\n", rawdata[1], rawdata[2]);
            return 1;
    }
    return 0;
}
\end{lstlisting}

\lstset{caption={Header file for RPi comms library. (rpi/mc\_comms.hh)}, label=ls:mccomms_h}\linespread{0.8}
\begin{lstlisting}
#ifndef _MC_COMMS_H
#define _MC_COMMS_H

#include <stdint.h>

#define SERIAL_DEVICE "/dev/serial0"
#define RECVBUFFER_SIZE 5
#define SENDBUFFER_SIZE 5

FILE* uartInit(const char* device);
void uartClose(FILE* uartDevice);
char* uartReadRaw(FILE* uartDevice);
int uartSendRaw(char* string, FILE* uartDevice);
int uartSendCommand(uint8_t command, int16_t data, FILE* uartDevice);

#endif
\end{lstlisting}

\lstset{caption={RPi comms library. (rpi/mc\_comms.cc)}, label=ls:mccomms}\linespread{0.8}
\begin{lstlisting}
#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/mman.h>
#include <time.h>
#include <string.h>

#include "mc_comms.hh"
#include "../constants.h"

FILE* uartInit(const char* device)
{
    static FILE *serial = fopen(device, "r+");
    
    /* Making fgets non-blocking 
    http://stackoverflow.com/a/6055774 */
    int fd = fileno(serial);
    int flags = fcntl(fd, F_GETFL, 0);
    flags |= O_NONBLOCK;
    fcntl(fd, F_SETFL, flags);
    
    /* fclose(serial); */
    
    return serial;
}

void uartClose(FILE* uartDevice)
{
    fclose(uartDevice);
}

int uartSendRaw(char* string, FILE* uartDevice)
{
    if (strlen(string) > SENDBUFFER_SIZE)
    {
        return 1;
    }
    fwrite(string, sizeof(char), SENDBUFFER_SIZE, uartDevice);
    return 0;
}

int uartSendCommand(uint8_t command, int16_t data, FILE* uartDevice)
{
    char toSend[5];
    if ((command < 0x20) | (command > RECV_MAX))
    {
        return 1;
    }
    
    /*
        Convert 8 bit command and 16 bit data in to a 24 bit string.
        8 bit command, 2x 8 bit data.
        CCCCCCCC|DDDDDDDD|DDDDDDDD
    */
    toSend[0] = (char)command;
    toSend[1] = (char)(data >> 8);
    toSend[2] = (char)(data & 0x00FF);
    toSend[3] = (char)'\n';
    toSend[4] = (char)'\0';
    
    uartSendRaw(toSend, uartDevice);
    
    return 0;
}

int uartReadRaw(FILE* uartDevice, char* recvBuffer)
{    
    if (fgets(recvBuffer, RECVBUFFER_SIZE, uartDevice) != NULL)
    {
        return 0;
    }
    return 1;
}
\end{lstlisting}

\lstset{caption={PS4 Controller to RPi UART test. (rpi/tests/test-ps4-uart.cc)}, label=ls:ps4uarttest}\linespread{0.8}
\begin{lstlisting}
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Copyright Drew Noakes 2013-2016
//
// File first modified by Charlie Mason 25/02/2017

#include <unistd.h>

#include "joystick.hh"
#include "mc_comms.hh"
#include "../constants.h"

// Negative values correspond to the direction in variable names (positive for opposite direction)
int16_t servoButton = 0; //Turn on/off electromagnet
int16_t modeButton = 0; //Acts as mode switch between joystick and motion control methods
int16_t throttleUp = 0; // Axis 1
int16_t yawCCW = 0;       // Axis 0
int16_t pitchForward = 0;  // Axis 5 (Joystick) Axis 13 (Motion)
int16_t rollLeft = 0;      // Axis 2 (Joystick) Axis 11 (Motion)

int main(int argc, char** argv)
{
  const char uartDevice[] = "/dev/serial0";
  FILE* serialDevice = uartInit(uartDevice);
  char toSend[SENDBUFFER_SIZE] = "";

// Create an instance of Joystick
  Joystick joystick("/dev/input/js0");

  // Ensure that it was found and that we can use it
  if (joystick.isFound())
  {
    printf("Joystick Connected.\n");
  }
  else
  {
    printf("Joystick not detected, exiting.\n");
    exit(1);
  }

  while (true)
  {
    // Restrict rate
    usleep(1000);

    // Attempt to sample an event from the joystick
    JoystickEvent event;
    if (joystick.sample(&event))
    {
      if (event.isButton())
      {
	if (event.number == 1)
	  {
	    modeButton = event.value;
	    printf("Button %u is %s\n", event.number, modeButton == 0 ? "up" : "down");
            uartSendCommand(MODE_BUTTON, modeButton, serialDevice);

            if (event.value == 0)
	    {
	      pitchForward = 0;
	      rollLeft = 0;
	      printf("Pitch and Roll reset, now in JOYSTICK mode\n");
	    }
	  }
	else if (event.number == 0)
	  {
	    servoButton = event.value;
	    printf("Button %u is %s\n", event.number, servoButton == 0 ? "up" : "down");
            uartSendCommand(SERVO_BUTTON, servoButton, serialDevice);
          }
      }
      else if (event.isAxis())
      {
	if (modeButton && (event.number > 5 || event.number == 1))
	{
	  switch(event.number)
	  {
	    case 1 : throttleUp = event.value;
                     uartSendCommand(THROTTLE_UP, throttleUp, serialDevice);
		     break;
	    case 11: rollLeft = -event.value;
                     uartSendCommand(ROLL_LEFT, rollLeft, serialDevice);
		     break;
	    case 13: pitchForward = -event.value;
                     uartSendCommand(PITCH_FORWARD, pitchForward, serialDevice);
		     break;
	  }
	printf("MOTION Throttle: %6d, Roll: %6d, Pitch: %6d\n", throttleUp, rollLeft, pitchForward);
	}
	else if (modeButton == 0 && event.number <= 5)
	{
	  switch(event.number)
	  {
	    case 0 : yawCCW = event.value;
                     uartSendCommand(YAW_CCW, yawCCW, serialDevice);
		     break;
	    case 1 : throttleUp = event.value;
                     uartSendCommand(THROTTLE_UP, throttleUp, serialDevice);
		     break;
	    case 2 : rollLeft = event.value;
                     uartSendCommand(ROLL_LEFT, rollLeft, serialDevice);
		     break;
	    case 5 : pitchForward = event.value;
                     uartSendCommand(PITCH_FORWARD, pitchForward, serialDevice);
		     break;
	  }
	printf("JOYSTICK Throttle: %6d, Yaw: %6d, Roll: %6d, Pitch: %6d\n", throttleUp, yawCCW, rollLeft, pitchForward);
	}	
      }
    }
  }
}
\end{lstlisting}

\end{document}